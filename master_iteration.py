import csv 
import numpy as np
import random as ran
import sys

from sklearn.model_selection import StratifiedKFold
from sklearn.semi_supervised import LabelLambda
from sklearn.semi_supervised import LabelSpreading
from sklearn.semi_supervised import LabelPropagation
from sklearn.naive_bayes import BernoulliNB
from sklearn.neighbors import KNeighborsClassifier


splits=5
seed=82948749203
threshold=10
jobs=4

malware=1
benign=0
unlab=-1


lm_a=int(sys.argv[1])/100
lb_a=int(sys.argv[2])/100
gamma=int(sys.argv[3])/10
kNN=int(sys.argv[4])
kern=sys.argv[5]
method=sys.argv[6]
limit=int(sys.argv[7])
rate=int(sys.argv[8])
t_mal=limit//(1+rate)
t_ben=limit-t_mal

def load_data():
    m_count=0
    b_count=0
    apps_features=[]
    with open('Scans_with_features.csv') as csvfile:
        spamreader = csv.reader(csvfile,delimiter=' ', quotechar='|')
        for row in spamreader:
            r=row[0].split(',')
            if int(r[-1])==0 and b_count<=t_ben:
                apps_features.append(r)
                b_count+=1
            if int(r[-1])>=threshold and m_count<=t_mal:
                apps_features.append(r)
                m_count+=1
    return apps_features

   
def soft_clamping(kernel,xTrain,yTrain,MI=10000,k=3,g=0.6,a=0.1):
    for itera in range(1,10000,100):
        spread = LabelSpreading(kernel=kernel,n_neighbors=k,gamma=g,alpha=a,max_iter=MI,n_jobs=-1)
        spread.fit(xTrain, yTrain)
        evaledY=spread.predict(xTrain)
        #def stats(trainY,evaledY,expectedY,day_one): return 
        lm_to_b,lb_to_m,tp,tn,fp,fn,pred_day1,missed_day1 = stats(yTrain,evaledY,yExpect,day_one)
        
        results=['SC',itera,kernel,k,g,a,lm_to_b,lb_to_m,tp,tn,fp,fn,pred_day1,missed_day1]
        file_name='SC_Iter_Tests.csv'
        write_csv(file_name,results)    	
    	    
    	            
def hard_clamping(kernel,k,xTrain,yTrain,MI=10000,g=0.6):
    prop = LabelPropagation(kernel=kernel,n_neighbors=k,gamma=g,max_iter=MI,n_jobs=-1)
    prop.fit(xTrain, yTrain) 
    evaledY=prop.predict(xTrain)
    #def stats(trainY,evaledY,expectedY,day_one): return 
    lm_to_b,lb_to_m,tp,tn,fp,fn,pred_day1,missed_day1 = stats(yTrain,evaledY,yExpect,day_one)
    
    results=['HC',kernel,k,g,lm_to_b,lb_to_m,tp,tn,fp,fn,pred_day1,missed_day1]

    file_name='HC_'+str(rate)+'.csv'    
    write_csv(file_name,results)
    
def variant(xTrain,yTrain,lm_alpha,lb_alpha,um_alpha,ub_alpha,kernel,k,g=0.6,MI=10000):
    lamb=[]
    for i in range(len(yTrain)):
        if yTrain[i]==malware:
            lamb.append(lm_alpha)
        elif yTrain[i]==benign:
            lamb.append(lb_alpha)

        elif yTrain[i]==unlab:
            lamb.append(um_alpha)

    lp = LabelLambda(kernel=kernel,n_neighbors=k,gamma=g,lam=lamb,max_iter=MI,n_jobs=-1)
    lp.fit(xTrain, yTrain) 
    evaledY=lp.predict(xTrain)
    
    #def stats(trainY,evaledY,expectedY,day_one): return 
    lm_to_b,lb_to_m,tp,tn,fp,fn,pred_day1,missed_day1 = stats(yTrain,evaledY,yExpect,day_one)

    results=['Var',kernel,k,g,lm_alpha,lb_alpha,ub_alpha,lm_to_b,lb_to_m,tp,tn,fp,fn,pred_day1,missed_day1]
    
    file_name='VAR_'+str(rate)+'.csv'    
    write_csv(file_name,results)


def NB(xTrain,yTrain,MI=1000):
    clf = BernoulliNB()
    clf.fit(xTrain, yTrain)

    evaledY=clf.predict(xTrain)
    lm_to_b,lb_to_m,tp,tn,fp,fn,pred_day1,missed_day1 = stats(yTrain,evaledY,yExpect,day_one)

    results=['NB',lm_to_b,lb_to_m,tp,tn,fp,fn,pred_day1,missed_day1]
    file_name='NB_'+str(rate)+'.csv'
    
    write_csv(file_name,results)


def k_nearest(xTrain,yTrain,k=3):
    neigh = KNeighborsClassifier(n_neighbors=k,n_jobs=-1)

    neigh.fit(xTrain, yTrain) 
    
    evaledY=neigh.predict(xTrain)

    lm_to_b,lb_to_m,tp,tn,fp,fn,pred_day1,missed_day1 = stats(yTrain,evaledY,yExpect,day_one)

    results=['KNN',k,lm_to_b,lb_to_m,tp,tn,fp,fn,pred_day1,missed_day1]
    
    file_name='KNN_'+str(rate)+'.csv'
    write_csv(file_name,results)

def stats(trainY,evaledY,expectedY,day_one):
    pred_day1,missed_day1=0,0
    lm_to_b,lb_to_m,tp,tn,fp,fn=0,0,0,0,0,0

    for i in range(len(evaledY)):
        if trainY[i]!=unlab:
            if expectedY[i]==malware:
                if evaledY[i]==benign:
                    lm_to_b+=1
            else:
                if evaledY[i]==malware:
                    lb_to_m+=1 
            
        else:    
            if expectedY[i]==malware:
                if evaledY[i]==malware:
                    tp+=1
                else:
                    fn+=1
            else:
                if evaledY[i]==malware:
                    fp+=1
                else:
                    tn+=1   
        if day_one[i]==1:
            if evaledY[i]==malware:
                pred_day1+=1
            else:
                missed_day1+=1
    
    return lm_to_b,lb_to_m,tp,tn,fp,fn,pred_day1,missed_day1

def build_matrix(train,test):
    tot=len(train)+len(test)
    
    xTrain=np.zeros((tot,470))
    yTrain=np.zeros((tot,1))
    yExpect=np.zeros((tot,1))
    day_one=np.zeros((tot,1))

    for i in range(len(train)):
        app=train[i]
        first_scan=int(app[2])
        second_scan=int(app[-1])
           
            
        for p in range(4,474):
            xTrain[i][p-4]=int(app[p]) 
                 
        if second_scan == 0:
            yExpect[i]=benign
        elif second_scan >= threshold:
            yExpect[i]=malware
            if first_scan == 0:
                day_one[i]=1

        if first_scan == 0:
            yTrain[i]=benign
        elif first_scan >= threshold:
            yTrain[i]=malware        
    
    for i in range(len(test)):
        app=test[i]
        first_scan=int(app[2])
        second_scan=int(app[-1])
           
            
        for p in range(4,474):
            xTrain[i+len(train)][p-4]=int(app[p])
                 
        if second_scan == 0:
            yExpect[i+len(train)]=benign
        elif second_scan >= threshold:
            yExpect[i+len(train)]=malware
            if first_scan == 0:
                day_one[i+len(train)]=1
        yTrain[i+len(train)]=unlab 
                
    return xTrain,yTrain, yExpect, day_one
    


def write_csv(file_name,data):
    with open(file_name, "a") as f:        
        for i in data:
            f.write(str(i))
            f.write(",")
        f.write("\n")


ran.seed(seed)
data=load_data()
print("loaded data")
threshhold_data=[]
starting_labels=[]
ending_labels=[]

um_a,ub_a=0,0
#for soft clamping
alpha_values=[i/10 for i in range(1,9)]

for i in data:
    apk=i[3]
    first_scan=int(i[2])
    second_scan=int(i[-1])
    #apks.append(apk)
    

    if first_scan ==0:
        if second_scan ==0:
            threshhold_data.append(i)
            starting_labels.append(benign)
            ending_labels.append(benign)
        elif second_scan>=threshold:
            threshhold_data.append(i)
            starting_labels.append(benign)
            ending_labels.append(malware)
                        
    elif first_scan>=threshold:
        if second_scan ==0:
            threshhold_data.append(i)
            starting_labels.append(malware)
            ending_labels.append(benign)
        elif second_scan>=threshold:
            threshhold_data.append(i)
            starting_labels.append(malware)
            ending_labels.append(malware)
        
skf = StratifiedKFold(n_splits=splits)
skf.get_n_splits(threshhold_data,ending_labels)
print("stratified")

for train_indexs, test_indexs in skf.split(threshhold_data,ending_labels):
    test_set=[]
    train_set=[]
    
    for i in train_indexs:
        train_set.append(threshhold_data[i])
    for i in test_indexs:
        test_set.append(threshhold_data[i])
        
    xTrain,yTrain, yExpect, day_one =  build_matrix(train_set,test_set)
    print("built matrix") 
    if method=='var':
        for u_a in alpha_values:
            variant(xTrain,yTrain,lm_a,lb_a,u_a,u_a,kern,kNN,g=gamma)
    elif method=='sc':
        #for sc_a in alpha_values:
        soft_clamping(kern,xTrain,yTrain,k=kNN,g=gamma,a=0.8)
    elif method=='hc':
        hard_clamping(kern,kNN,xTrain,yTrain.ravel(),g=gamma)
    elif method=='knn':
        k_values=[1,3,5,7]
        for k in k_values:
            k_nearest(xTrain,yTrain.ravel(),k=k)
    elif method=='nb':
        NB(xTrain,yTrain.ravel())
    
